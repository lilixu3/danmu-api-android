name: Manual Build APK + Publish Release (pull danmu_api dir only, fixed signing)

on:
  workflow_dispatch:
    inputs:
      danmu_repo:
        description: "danmu_api 仓库（owner/repo）"
        required: true
        default: "lilixu3/danmu_api"
      danmu_ref:
        description: "danmu_api 分支/Tag/提交（ref）"
        required: true
        default: "main"
      app_version_name:
        description: "APP versionName（例如 0.2.1）"
        required: true
        default: "0.1.0"
      app_version_code:
        description: "APP versionCode（整数，例如 21）"
        required: true
        default: "1"
      release_tag:
        description: "发行版 Tag（留空则用 v{versionName}）"
        required: false
        default: ""
      nodejs_mobile_tag:
        description: "nodejs-mobile tag（例如 v18.20.4）"
        required: true
        default: "v18.20.4"
      build_variant:
        description: "release 或 debug"
        required: true
        default: "release"

permissions:
  contents: write

env:
  # 目标：把“另一个仓库里的 danmu_api/ 子目录内容”同步到这里
  DANMU_PATH: app/src/main/assets/nodejs-project/danmu_api

  ANDROID_API: "34"
  BUILD_TOOLS: "34.0.0"
  NDK_VERSION: "25.1.8937393"
  CMAKE_VERSION: "3.22.1"

jobs:
  build_and_release:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout app repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      # ✅ 固定签名：强制用你设置的这 4 个 secrets（名字必须一致）
      - name: Prepare signing keystore (REQUIRED, reproducible)
        env:
          ANDROID_KEYSTORE_BASE64: ${{ secrets.ANDROID_KEYSTORE_BASE64 }}
          ANDROID_KEYSTORE_PASSWORD: ${{ secrets.ANDROID_KEYSTORE_PASSWORD }}
          ANDROID_KEY_ALIAS: ${{ secrets.ANDROID_KEY_ALIAS }}
          ANDROID_KEY_PASSWORD: ${{ secrets.ANDROID_KEY_PASSWORD }}
        run: |
          set -euo pipefail
          if [ -z "${ANDROID_KEYSTORE_BASE64:-}" ]; then
            echo "❌ Missing secret: ANDROID_KEYSTORE_BASE64"
            exit 1
          fi
          echo "$ANDROID_KEYSTORE_BASE64" | base64 -d > "$GITHUB_WORKSPACE/ci_keystore.jks"
          KEYSTORE_PATH="$(realpath "$GITHUB_WORKSPACE/ci_keystore.jks")"

          echo "ANDROID_KEYSTORE_PATH=$KEYSTORE_PATH" >> $GITHUB_ENV
          echo "ANDROID_KEYSTORE_PASSWORD=$ANDROID_KEYSTORE_PASSWORD" >> $GITHUB_ENV
          echo "ANDROID_KEY_ALIAS=$ANDROID_KEY_ALIAS" >> $GITHUB_ENV
          echo "ANDROID_KEY_PASSWORD=$ANDROID_KEY_PASSWORD" >> $GITHUB_ENV

          echo "✅ Keystore: $KEYSTORE_PATH"

      # ✅ 只取另一个仓库的 danmu_api/ 子目录（不要把 .git 带进 assets）
      - name: Checkout danmu_repo (sparse checkout danmu_api dir)
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.danmu_repo }}
          ref: ${{ inputs.danmu_ref }}
          path: danmu_tmp
          fetch-depth: 1
          sparse-checkout: |
            danmu_api
          sparse-checkout-cone-mode: true

      - name: Sync danmu_api dir into assets (NO .git, NO nesting)
        run: |
          set -euo pipefail
          if [ ! -d "danmu_tmp/danmu_api" ]; then
            echo "❌ danmu_tmp/danmu_api 不存在（检查仓库结构/分支）"
            ls -lah danmu_tmp || true
            exit 1
          fi

          rm -rf "${DANMU_PATH}"
          mkdir -p "${DANMU_PATH}"

          # 把 danmu_tmp/danmu_api/ 的“内容”同步到目标目录（避免出现 danmu_api/danmu_api 这种双层）
          rsync -a --delete "danmu_tmp/danmu_api/" "${DANMU_PATH}/"

          # 安全兜底：assets 内绝对不要出现 git 元数据
          rm -rf "${DANMU_PATH}/.git" "${DANMU_PATH}/.github" || true

          echo "==== verify danmu_api layout ===="
          test -f "${DANMU_PATH}/worker.js" || {
            echo "❌ 缺少 ${DANMU_PATH}/worker.js（说明还是目录不对）"
            find "${DANMU_PATH}" -maxdepth 3 -type f | sed -n '1,200p'
            exit 1
          }
          # 防止双层
          if [ -d "${DANMU_PATH}/danmu_api" ]; then
            echo "❌ 检测到 ${DANMU_PATH}/danmu_api（双层嵌套），会导致 import 路径错误"
            exit 1
          fi

      - name: Setup JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"

      - name: Setup Android SDK
        uses: android-actions/setup-android@v3

      - name: Install Android components (platform/build-tools/ndk/cmake)
        run: |
          set -euo pipefail
          sdkmanager "platforms;android-${ANDROID_API}" \
                     "build-tools;${BUILD_TOOLS}" \
                     "platform-tools" \
                     "ndk;${NDK_VERSION}" \
                     "cmake;${CMAKE_VERSION}"

      - name: Set up Gradle
        uses: gradle/actions/setup-gradle@v4

      - name: Download nodejs-mobile Android zip and place into app/libnode (ARM only + include mirror)
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          rm -rf /tmp/nodejs-mobile
          mkdir -p /tmp/nodejs-mobile
          cd /tmp/nodejs-mobile

          gh release download "${{ inputs.nodejs_mobile_tag }}" \
            -R nodejs-mobile/nodejs-mobile \
            -p "*android*.zip"

          unzip -q *.zip -d extracted

          NODE_H="$(find extracted -type f -path "*/include/node/node.h" | head -n 1 || true)"
          if [ -z "$NODE_H" ]; then
            echo "❌ 没找到 include/node/node.h，zip 结构异常："
            find extracted -maxdepth 6 -type d | sed -n '1,200p'
            exit 1
          fi
          INCLUDE_ROOT="$(dirname "$(dirname "$NODE_H")")"  # .../include

          rm -rf "$GITHUB_WORKSPACE/app/libnode"
          mkdir -p "$GITHUB_WORKSPACE/app/libnode/include" "$GITHUB_WORKSPACE/app/libnode/bin"

          # 1) include/ -> app/libnode/include/
          rsync -a "$INCLUDE_ROOT"/ "$GITHUB_WORKSPACE/app/libnode/include/"

          # 2) 兼容：工程只加了 -I include/node，所以把 include 下除 node/ 外的头镜像到 include/node/
          mkdir -p "$GITHUB_WORKSPACE/app/libnode/include/node"
          rsync -a --exclude 'node/' "$GITHUB_WORKSPACE/app/libnode/include/" "$GITHUB_WORKSPACE/app/libnode/include/node/"

          # 3) 仅 ARM 两个 ABI 的 libnode.so
          for ABI in armeabi-v7a arm64-v8a; do
            LIB="$(find extracted -type f -path "*/${ABI}/libnode.so" | head -n 1 || true)"
            if [ -z "$LIB" ]; then
              echo "❌ 没找到 ${ABI}/libnode.so"
              exit 1
            fi
            mkdir -p "$GITHUB_WORKSPACE/app/libnode/bin/${ABI}"
            cp -f "$LIB" "$GITHUB_WORKSPACE/app/libnode/bin/${ABI}/libnode.so"
            echo "✅ libnode.so for ${ABI}: $LIB"
          done

          test -f "$GITHUB_WORKSPACE/app/libnode/include/node/node.h"
          test -f "$GITHUB_WORKSPACE/app/libnode/bin/arm64-v8a/libnode.so"

      - name: Normalize timestamps (fix ninja dirty loop)
        run: |
          set -euo pipefail
          find . -type f -exec touch {} +

      - name: Patch native-lib.cpp (argv const -> non-const)
        run: |
          set -euo pipefail
          FILE="app/src/main/cpp/native-lib.cpp"
          if [ -f "$FILE" ]; then
            sed -i 's/return node::Start(argc, argv.data());/return node::Start(argc, const_cast<char**>(argv.data()));/g' "$FILE"
          fi

      - name: Clean native build cache (.cxx)
        run: rm -rf app/.cxx || true

      - name: Grant execute permission to gradlew
        run: chmod +x ./gradlew

      - name: Build APK
        env:
          GRADLE_OPTS: "-Dorg.gradle.jvmargs=-Xmx2g -Dkotlin.daemon.jvm.options=-Xmx1g"
        run: |
          set -euo pipefail
          if [ "${{ inputs.build_variant }}" = "debug" ]; then
            ./gradlew :app:clean :app:assembleDebug \
              -PAPP_VERSION_NAME="${{ inputs.app_version_name }}" \
              -PAPP_VERSION_CODE="${{ inputs.app_version_code }}" \
              --no-daemon --stacktrace
          else
            ./gradlew :app:clean :app:assembleRelease \
              -PAPP_VERSION_NAME="${{ inputs.app_version_name }}" \
              -PAPP_VERSION_CODE="${{ inputs.app_version_code }}" \
              --no-daemon --stacktrace
          fi

      - name: Collect APKs (split by ABI)
        id: apk
        run: |
          set -euo pipefail
          VARIANT="${{ inputs.build_variant }}"
          APK_DIR="app/build/outputs/apk/${VARIANT}"
          mkdir -p dist

          for ABI in arm64-v8a armeabi-v7a; do
            SRC="$(find "$APK_DIR" -maxdepth 2 -type f -name "*.apk" | grep "$ABI" | head -n 1 || true)"
            if [ -z "$SRC" ]; then
              echo "❌ 没找到 ${ABI} 的 APK"
              find "$APK_DIR" -maxdepth 2 -type f -name "*.apk" || true
              exit 1
            fi
            OUT="dist/DanmuApiApp-${{ inputs.app_version_name }}-${VARIANT}-${ABI}.apk"
            cp -f "$SRC" "$OUT"
            echo "✅ ${ABI}: $OUT"
          done

          ls -lh dist

      - name: Compute release tag/name/body
        id: rel
        run: |
          set -euo pipefail
          if [ -n "${{ inputs.release_tag }}" ]; then
            TAG="${{ inputs.release_tag }}"
          else
            TAG="v${{ inputs.app_version_name }}"
          fi
          NAME="DanmuApiApp ${{ inputs.app_version_name }} (${{ inputs.build_variant }})"
          BODY=$'danmu_api: '${{ inputs.danmu_repo }}$'\nref: '${{ inputs.danmu_ref }}$'\nversionName: '${{ inputs.app_version_name }}$'\nversionCode: '${{ inputs.app_version_code }}

          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "name=$NAME" >> "$GITHUB_OUTPUT"
          echo "body<<EOF" >> "$GITHUB_OUTPUT"
          echo "$BODY" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Create / update GitHub Release and upload APKs
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          TAG="${{ steps.rel.outputs.tag }}"
          REPO="${GITHUB_REPOSITORY}"

          if gh release view "$TAG" -R "$REPO" >/dev/null 2>&1; then
            gh release edit "$TAG" -R "$REPO" --title "${{ steps.rel.outputs.name }}" --notes "${{ steps.rel.outputs.body }}"
          else
            gh release create "$TAG" -R "$REPO" --title "${{ steps.rel.outputs.name }}" --notes "${{ steps.rel.outputs.body }}"
          fi

          gh release upload "$TAG" -R "$REPO" dist/*.apk --clobber
          echo "✅ Uploaded: https://github.com/${REPO}/releases/tag/${TAG}"
